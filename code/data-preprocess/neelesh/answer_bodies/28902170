<p>One method would be to store the result of an inner merge form both dfs, then we can simply select the rows when one column's values are not in this common:</p>

<pre><code>In [119]:

common = df1.merge(df2,on=['col1','col2'])
print(common)
df1[(~df1.col1.isin(common.col1))&amp;(~df1.col2.isin(common.col2))]
   col1  col2
0     1    10
1     2    11
2     3    12
Out[119]:
   col1  col2
3     4    13
4     5    14
</code></pre>

<p><strong>EDIT</strong></p>

<p>Another method as you've found is to use <code>isin</code> which will produce <code>NaN</code> rows which you can drop:</p>

<pre><code>In [138]:

df1[~df1.isin(df2)].dropna()
Out[138]:
   col1  col2
3     4    13
4     5    14
</code></pre>

<p>However if df2 does not start rows in the same manner then this won't work:</p>

<pre><code>df2 = pd.DataFrame(data = {'col1' : [2, 3,4], 'col2' : [11, 12,13]})
</code></pre>

<p>will produce the entire df:</p>

<pre><code>In [140]:

df1[~df1.isin(df2)].dropna()
Out[140]:
   col1  col2
0     1    10
1     2    11
2     3    12
3     4    13
4     5    14
</code></pre>
